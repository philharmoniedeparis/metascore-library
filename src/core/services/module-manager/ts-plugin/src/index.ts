import type ts from 'typescript/lib/tsserverlibrary'
import path from 'node:path'
import fs from 'node:fs'

const REGISTRY_FILE_PATH = path.resolve(__dirname, '../types.d.ts')

function updateRegistry(typescript: typeof ts, info: ts.server.PluginCreateInfo) {
  const program = info.languageService.getProgram();
  if (!program) return;

  const modules = new Map();

  for (const sourceFile of program.getSourceFiles()) {
    if (!sourceFile.fileName.endsWith(".ts")) continue;
    if (sourceFile.fileName.includes("/__mocks__/")) continue;

    typescript.forEachChild(sourceFile, (node) => {
      // Check if this is a class declaration.
      if (typescript.isClassDeclaration(node) && node.heritageClauses) {
        for (const heritageClause of node.heritageClauses) {
          if (heritageClause.token === typescript.SyntaxKind.ExtendsKeyword) {
            const baseClass = heritageClause.types[0]?.expression.getText(sourceFile);
            // Check if the class extends AbstractModule.
            if (baseClass === "AbstractModule" && node.name) {
              // Find thevalue of the id property.
              const id = node.forEachChild((class_child) => {
                if (typescript.isPropertyDeclaration(class_child) && typescript.getNameOfDeclaration(class_child)?.getText(sourceFile) === "id") {
                  return class_child.forEachChild((property_child) => {
                    if (typescript.isStringLiteral(property_child)) {
                      return property_child.text;
                    }
                  });
                }
              });
              if (id) modules.set(id, {
                name: node.name.getText(sourceFile),
                path: sourceFile.fileName,
              });
            }
          }
        }
      }
    });
  }

  let imports = "";
  let map = "export type ModulesMap = {\n";
  new Map([...modules.entries()].sort()).forEach((module, id) => {
    const module_path = path.relative(path.dirname(REGISTRY_FILE_PATH), module.path);
    imports += `import type ${module.name} from "${module_path}";\n`;
    map += `  "${id}": typeof ${module.name}\n`;
  });
  map += "}\n\n";
  map += "export type ModuleId = keyof ModulesMap;\n"

  const content = `// This file is auto-generated by the TypeScript plugin\n\n${imports}\n${map}`

  try {
    fs.mkdirSync(path.dirname(REGISTRY_FILE_PATH), { recursive: true });
    fs.writeFileSync(REGISTRY_FILE_PATH, content, { encoding: "utf8" });
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (error) {
    info.project.projectService.logger.info(`Could not write to ${REGISTRY_FILE_PATH}`);
  }

  info.project.projectService.logger.info(`Updated module registry: ${REGISTRY_FILE_PATH}`);
}

module.exports = function init(modules: { typescript: typeof ts }) {
  return {
    create: (info: ts.server.PluginCreateInfo) => {
      info.project.projectService.logger.info("Module Manager TS Plugin Loaded");

      const proxy = Object.create(null);
      for (const k of Object.keys(info.languageService) as Array<keyof ts.LanguageService>) {
        const x = info.languageService[k]!;
        // @ts-expect-error - JS runtime trickery which is tricky to type tersely
        proxy[k] = (...args) => x.apply(info.languageService, args);
      }

      // Hook into program updates (e.g., file changes)
      proxy.getSemanticDiagnostics = (fileName: string) => {
        updateRegistry(modules.typescript, info); // Regenerate the registry on each call

        return info.languageService.getSemanticDiagnostics(fileName);
      };

      return proxy;
    }
  }
}
