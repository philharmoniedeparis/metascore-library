import ts from 'typescript';
import { dirname, relative, resolve, isAbsolute } from 'node:path';
import { mkdir, writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import { type Plugin } from 'vite';

const PLUGIN_NAME = 'metascore-library:generate-types'

function isFileInDirectory(filePath: string, dirPath: string) {
  try {
    // Resolve absolute paths
    const absoluteFilePath = resolve(filePath);
    const absoluteDirPath = resolve(dirPath);

    // Normalize paths to avoid traversal attacks
    const relativePath = relative(absoluteDirPath, absoluteFilePath);

    // Check if the relative path attempts to go outside the directory
    return !relativePath.startsWith("..") && !isAbsolute(relativePath);
  } catch (error) {
    console.error("Error checking file path:", error);
    return false;
  }
}

function parseTsConfig(configPath: string) {
  const parseConfigHost: ts.ParseConfigHost = {
    fileExists: ts.sys.fileExists,
    readDirectory: ts.sys.readDirectory,
    readFile: ts.sys.readFile,
    useCaseSensitiveFileNames: true,
  };
  const result = ts.parseJsonConfigFileContent(
    ts.readConfigFile(configPath, ts.sys.readFile).config,
    parseConfigHost,
    dirname(configPath)
  );
  return result;
}

async function updateRegistry(sourceFiles: readonly ts.SourceFile[], srcDir: string, outFile: string) {
  const modules = new Map();

  sourceFiles
    .filter((sourceFile) => {
      return isFileInDirectory(sourceFile.fileName, srcDir) &&
        sourceFile.fileName.endsWith(".ts") &&
        !sourceFile.fileName.includes("/__mocks__/") &&
        !sourceFile.isDeclarationFile;
    })
    .forEach((sourceFile) => {
      ts.forEachChild(sourceFile, (node) => {
        // Check if this is a class declaration.
        if (ts.isClassDeclaration(node) && node.heritageClauses) {
          for (const heritageClause of node.heritageClauses) {
            if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
              const baseClass = heritageClause.types[0]?.expression.getText(sourceFile);
              // Check if the class extends AbstractModule.
              if (baseClass === "AbstractModule" && node.name) {
                // Find thevalue of the id property.
                const id = node.forEachChild((class_child) => {
                  if (ts.isPropertyDeclaration(class_child) && ts.getNameOfDeclaration(class_child)?.getText(sourceFile) === "id") {
                    return class_child.forEachChild((property_child) => {
                      if (ts.isStringLiteral(property_child)) {
                        return property_child.text;
                      }
                    });
                  }
                });
                if (id) modules.set(id, {
                  name: node.name.getText(sourceFile),
                  path: sourceFile.fileName,
                });
              }
            }
          }
        }
      });
    });

  let imports = "";
  let map = "  export interface ModulesMap {\n";
  new Map([...modules.entries()].sort()).forEach((module, id) => {
    const module_path = relative(dirname(outFile), module.path);
    imports += `import type ${module.name} from "${module_path}";\n`;
    map += `    "${id}": typeof ${module.name}\n`;
  });
  map += "  }";

  const content = `// This file is auto-generated by the ${PLUGIN_NAME} vite plugin\n\n${imports}\ndeclare module '../src/core/services/module-manager' {\n${map}\n}`

  try {
    await mkdir(dirname(outFile), { recursive: true });
    await writeFile(outFile, content, { encoding: "utf8" });
  } catch (error) {
    console.error(`Could not write to ${outFile}`, error);
  }

  console.info(`Updated module registry: ${outFile}`);
}

export interface Options {
  srcDir: string
  outFile: string
}

const DEFAULTS:Options = {
  srcDir: fileURLToPath(new URL('../../../src', import.meta.url)),
  outFile: fileURLToPath(new URL('../../../.types/generated.ts', import.meta.url)),
}

export default function generateTypes(options: Partial<Options> = {}): Plugin {
  const { srcDir, outFile } = {
    ...DEFAULTS,
    ...options
  };

  const configPath = ts.findConfigFile(
    /*searchPath*/ "./",
    ts.sys.fileExists,
    "tsconfig.app.json"
  );
  if (!configPath) {
    throw new Error("Could not find a valid 'tsconfig.app.json'.");
  }

  const config = parseTsConfig(configPath);
  const program = ts.createProgram({
    options: config.options,
    rootNames: config.fileNames,
    projectReferences: config.projectReferences,
    configFileParsingDiagnostics: config.errors,
  });

  return {
    name: PLUGIN_NAME,
    async buildStart() {
      const sourceFiles = program.getSourceFiles();
      await updateRegistry(sourceFiles, srcDir, outFile);
    },
    async handleHotUpdate() {
      const sourceFiles = program.getSourceFiles();
      await updateRegistry(sourceFiles, srcDir, outFile);
    }
  }
}
